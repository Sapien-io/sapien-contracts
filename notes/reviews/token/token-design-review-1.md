Design Issues and Recommendations for SapienToken Contract
| # | Issue | Category | Description | Recommendation |
| --- | --- | --- | --- | --- |
| 1 | Hardcoded vesting schedules | Flexibility | All vesting schedules are hardcoded in the contract initialization with fixed durations and parameters. | Create a configurable system where vesting parameters can be set during initialization rather than hardcoded. |
| 2 | Centralized token distribution | Trust | All tokens are initially minted to the deployer who must transfer them to the multisig, creating a trust requirement. | Mint tokens directly to the Gnosis Safe in the initialize function. |
| 3 | Limited allocation types | Extensibility | The contract uses a fixed enum for allocation types, making it impossible to add new types without upgrading. | Consider using a more flexible mapping or a factory pattern for allocation creation. |
| 4 | Monolithic contract design | Architecture | The contract handles both ERC20 functionality and complex vesting logic in a single contract. | Split into separate concerns: a token contract and a vesting manager contract. |
| 5 | Lack of governance mechanism | Administration | All administrative actions require the Gnosis Safe, with no delegation or voting capabilities. | Implement a governance system that allows token holders to participate in decision-making. |
| 6 | Unclear rewards mechanism | Integration | The relationship between the rewards contract and token vesting is not well-defined in the contract. | Document the intended relationship and interactions clearly with proper access controls. |
| 7 | No batch operations | Gas Efficiency | Each operation (like token release) must be executed individually for each allocation type. | Add batch functions to perform operations on multiple allocation types in a single transaction. |
| 8 | Non-standard naming conventions | Code Quality | The contract uses inconsistent naming for public variables (e.g., _gnosisSafe with a leading underscore). | Follow Solidity naming conventions: remove underscore from public variables. |
| 9 | Rigid safe address updates | Flexibility | Safe addresses cannot be changed after tokens have been released, creating potential issues if keys are compromised. | Implement a recovery mechanism with appropriate security controls. |
| 10 | Redundant access control | Architecture | The contract uses both Ownable2StepUpgradeable and custom onlySafe modifier, creating duplicate access control paths. | Standardize on one access control approach, preferably Ownable2Step with a clear role system. |
| 11 | No emergency stop for specific functions | Security | While the contract is Pausable, it only affects token transfers and releases, not administrative functions. | Implement granular pausing mechanisms for different contract functionalities. |
| 12 | Unclear interaction with DEXs | Integration | The contract doesn't specify how it interacts with DEXs for liquidity incentives. | Document the intended liquidity deployment strategy and implement specific functions if needed. |
| 13 | No migration path for token holders | Upgradability | While the contract is upgradeable, there's no clear migration path for token holders if a migration is necessary. | Define a token migration strategy and implement helper functions. |
| 14 | Limited vesting release flexibility | User Experience | Tokens can only be released by the Gnosis Safe or rewards contract, not by the recipients themselves. | Consider allowing recipients to trigger their own releases, subject to vesting rules. |
| 15 | Debugging import in production | Code Quality | The contract imports hardhat/console.sol, which should not be in production code. | Remove debugging imports before deployment. |
| 16 | No event filtering capabilities | Observability | Events lack indexed parameters that would make filtering easier for important fields. | Add more indexed parameters to events for better off-chain monitoring. |
| 17 | Lack of time buffer for vesting updates | Security | Vesting schedule updates take effect immediately, without a time buffer for stakeholders to react. | Implement a timelock for critical parameter changes. |
| 18 | No recipient notification mechanism | User Experience | When tokens are released, there's no direct notification to recipients. | Consider adding hooks or notifications for recipient wallets. |
| 19 | Linear vesting without customization | Flexibility | The vesting is strictly linear after the cliff, with no support for custom vesting curves. | Implement support for different vesting curve types (e.g., logarithmic, custom milestones). |
| 20 | Lack of documentation for integrators | Developer Experience | The contract lacks detailed documentation on how to integrate with it, especially for the rewards contract. | Create comprehensive integration documentation and examples. |
| 21 | No access control for vesting schedule viewing | Privacy | All vesting schedules are publicly visible, potentially revealing sensitive allocation information. | Consider implementing tiered access for viewing sensitive vesting information. |
| 22 | Fixed decimal precision | Compatibility | The contract uses a fixed 18 decimals, which may not be compatible with all systems. | Consider making the decimal precision configurable. |
| 23 | No native support for token lockups | Functionality | While the contract handles vesting, it doesn't natively support token lockups for events like token listings. | Add support for lockup periods separate from vesting schedules. |
| 24 | Limited support for multiple vesting schedules per allocation | Flexibility | Each allocation type can only have one vesting schedule, limiting complex distribution scenarios. | Support multiple schedules per allocation type for different tranches. |
| 25 | Two-tier upgrade system complexity | Maintenance | The two-tier upgrade system (authorize then upgrade) adds complexity that might not be necessary. | Simplify to a standard timelock approach if appropriate for the security model. |