Design Issues and Recommendations for SapienStaking Contract
This review focuses on design aspects, building on previous security and functional correctness assessments.
| # | Issue | Category | Description | Recommendation |
| --- | --- | --- | --- | --- |
| 1 | Centralized Signer (_sapienAddress) | Architecture & Trust | All core staking actions (stake, initiate/unstake, instant unstake) require a signature from a single _sapienAddress. This is a significant single point of failure and centralization risk. If this key is compromised, the entire staking system's integrity is at risk. | Implement a more decentralized or robust authorization mechanism. Options: <br> - Multi-sig for _sapienAddress: The _sapienAddress itself could be a multi-signature wallet. <br> - Role-Based Access Control: Define roles (e.g., ORDER_SIGNER_ROLE) and allow the Gnosis Safe to grant/revoke this role to multiple addresses. <br> - On-chain Oracle/Logic: For some actions, explore if an on-chain oracle or predefined logic could replace the need for a signature, though this is more complex. |
| 2 | No Mechanism to Update _sapienAddress | Maintainability & Security | If the _sapienAddress private key is compromised or needs to be rotated for operational reasons, there's no function to update it. This forces a contract upgrade for a critical operational parameter. | Add an onlySafe function (e.g., updateSapienSigner(address newSigner)) to allow the Gnosis Safe to change the _sapienAddress. This should emit an event. |
| 3 | Fixed Staking Parameters (Periods, Multipliers, Penalty) | Flexibility & Governance | Lock-up periods, multipliers, cooldown period, and early withdrawal penalty are hardcoded constants. The protocol cannot adapt to changing market conditions or community preferences without a contract upgrade. | Make these parameters configurable by the Gnosis Safe: <br> - Store them in state variables instead of constants. <br> - Add onlySafe functions to update them (e.g., setLockUpPeriodMultiplier(uint256 period, uint256 multiplier), setEarlyWithdrawalPenalty(uint256 newPenalty)). <br> - Emit events upon changes. <br> - Consider adding upper/lower bounds for sanity checks during updates. |
| 4 | Order ID Management (newOrderId, stakeOrderId) | User Experience & Complexity | The use of newOrderId for each action and referencing stakeOrderId adds complexity for users and off-chain systems. Each step requires a new, unique ID to be generated and signed for. | Simplify order ID management if possible. Could a single stakeOrderId be used as the primary identifier for a staking position through its lifecycle, with actions perhaps incrementing a nonce within that stake's context to prevent replay, rather than entirely new orderIds for each step? This would need careful EIP-712 redesign. |
| 5 | Lack of Reward Mechanism Definition | Core Functionality | The contract calculates and stores a multiplier but doesn't define how this multiplier translates into actual rewards or interacts with a rewards pool. The term "multiplier" implies a benefit, but its application is external to this contract. | If this contract is only for staking and tracking eligibility, this needs to be extremely clear in documentation. If it's meant to interact with a rewards system, consider: <br> - Interface for a rewards pool contract. <br> - Functions to claim rewards based on the multiplier and staked amount/duration. <br> - Clarity on whether rewards are auto-compounded or separately claimed. |
| 6 | DOMAIN_SEPARATOR Immutability Post-Fork | Robustness & Protocol Safety | DOMAIN_SEPARATOR is calculated in initialize using block.chainid. If the network forks and the contract is on a new chain with a different chainId, old signatures will become invalid, and new signatures might be replayed across forks if not handled carefully by clients. | While EIP-712 aims to prevent cross-chain replay, the contract itself doesn't have a mechanism to update its DOMAIN_SEPARATOR if block.chainid changes for the contract's perspective post-deployment (e.g. L2 re-genesis with new chain ID). This is a nuanced point, but for maximum robustness, consider if a re-initialization or update mechanism for the domain separator (highly restricted) might be needed in extreme scenarios, or ensure off-chain signature generation always uses the current, correct chain ID. |
| 7 | StakingInfo.isActive Redundancy | Gas & State Optimization | The isActive flag in StakingInfo is redundant. A stake is active if info.amount > 0. This adds an extra SLOAD/SSTORE. | Remove isActive and derive the status from info.amount > 0 in function logic. |
| 8 | Assembly for Ownership Storage | Readability & Risk | The getOwnable2StepStorage function uses assembly to access a specific storage slot for Ownable2StepUpgradeable. While this might be a pattern to save gas or deal with inheritance, it reduces readability and increases the risk of errors if OpenZeppelin's internal storage layout changes in future versions. | Rely on standard OpenZeppelin internal functions or storage access patterns if possible. If assembly is strictly necessary for a specific reason (e.g. overriding a private/internal OZ function's storage access), document the rationale and risks extensively. Current OZ UUPS patterns generally don't require this. |
| 9 | Event Emission for Partial Unstake Cooldown Reset | Observability | When a partial unstake occurs and info.cooldownStart is reset, no event is emitted. This makes it harder for off-chain systems to track the state of a user's cooldown. | Emit an event (e.g., CooldownReset(address indexed user, bytes32 indexed stakeOrderId)) when the cooldown is reset during a partial unstake. |
| 10 | No Explicit Way to Cancel initiateUnstake | User Experience | Once a user calls initiateUnstake, they are locked into the cooldown. There's no way to cancel this and re-activate the full stake without waiting for the cooldown and then re-staking. | Consider adding a function cancelUnstake(bytes32 stakeOrderId, bytes memory signature) that would allow a user (with a new signed message) to reset cooldownStart and cooldownAmount to 0, effectively cancelling the unstake process before unstake() is called. |
| 11 | Single _gnosisSafe for Admin and Penalty Recipient | Role Separation & Flexibility | The _gnosisSafe acts as the contract owner/admin and also the recipient of early withdrawal penalties. | For better role separation and future flexibility (e.g., routing penalties to a different treasury or burning them), consider having a separate penaltyRecipient address, configurable by the _gnosisSafe. |
| 12 | Use of days for Time Calculations | Precision | Using 30 days, 90 days, etc., assumes a fixed number of seconds per day (86400). This doesn't account for leap seconds and can lead to slight drifts over very long periods. | For financial contracts requiring high precision over many years, it's common practice to define periods in terms of a fixed number of seconds or rely on specific calendar libraries if exact month-end behavior is critical. For typical staking, days is often acceptable but be aware of the minor imprecision. |
| 13 | Lack of Batch Operations | Gas Efficiency & User Experience | Users with multiple staking positions or admins performing actions across many users/stakes would need to send individual transactions. | Consider adding batch functions for common operations if the use case supports it (e.g., batchStake if multiple pre-signed orders are submitted, or admin functions for batch data updates if ever needed). This adds complexity. |
| 14 | Clarity on TOKEN_DECIMALS | Code Readability | TOKEN_DECIMALS = 10 ** 18 is defined but not directly used in calculations visible within this contract, as MINIMUM_STAKE pre-calculates it. Its presence might imply it's used more broadly. | If TOKEN_DECIMALS is only for defining MINIMUM_STAKE, it could be inlined or its necessity reviewed. If the SAPIEN token might have variable decimals in other contexts, then keeping it is fine for clarity. |
| 15 | No Emergency Burn or Recovery for _sapienToken | Asset Management | If, for some extreme reason, tokens held by this contract needed to be burned or recovered by the Gnosis Safe (e.g., a catastrophic bug in the token itself discovered later), there's no direct mechanism. | This is an advanced/emergency feature. If deemed necessary, an onlySafe function like emergencyRecoverTokens(ERC20Upgradeable tokenAddress, address recipient, uint256 amount) could be added, allowing the safe to pull out any specified token (including _sapienToken) held by this contract. This is a powerful function and needs careful consideration. |
