// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.8.30;

import {Test} from "lib/forge-std/src/Test.sol";
import {SapienVault, ISapienVault} from "src/SapienVault.sol";
import {ERC1967Proxy} from "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {MockERC20} from "test/mocks/MockERC20.sol";
import {Constants as Const} from "src/utils/Constants.sol";

/**
 * @title SapienVault Lockup Vulnerability Test
 * @notice Tests to verify that the lockup period reduction vulnerability has been properly addressed
 * @dev This test file specifically addresses the vulnerability report:
 *      "Lockup Period for Unstaking Can Be Decreased by Staking Again with Shorter Lockup Period"
 */
contract SapienVaultLockupVulnerabilityTest is Test {
    SapienVault public sapienVault;
    MockERC20 public sapienToken;

    address public admin = makeAddr("admin");
    address public treasury = makeAddr("treasury");
    address public user1 = makeAddr("user1");

    uint256 public constant MINIMUM_STAKE = 1000e18; // 1,000 SAPIEN
    uint256 public constant LOCK_30_DAYS = 30 days;
    uint256 public constant LOCK_90_DAYS = 90 days;
    uint256 public constant LOCK_180_DAYS = 180 days;
    uint256 public constant LOCK_365_DAYS = 365 days;

    function setUp() public {
        // Deploy mock SAPIEN token
        sapienToken = new MockERC20("Sapien", "SAPIEN", 18);

        // Deploy SapienVault
        SapienVault sapienVaultImpl = new SapienVault();
        address dummySapienQA = makeAddr("dummySapienQA");
        bytes memory initData = abi.encodeWithSelector(
            SapienVault.initialize.selector,
            address(sapienToken),
            admin,
            makeAddr("pauseManager"),
            treasury,
            dummySapienQA
        );
        ERC1967Proxy sapienVaultProxy = new ERC1967Proxy(address(sapienVaultImpl), initData);
        sapienVault = SapienVault(address(sapienVaultProxy));

        // Mint tokens to user
        sapienToken.mint(user1, 100_000_000 * 1e18); // 100M tokens for testing
    }

    /**
     * @notice Test the exact exploit scenario described in the vulnerability report
     * @dev This test demonstrates that the vulnerability has been fixed
     */
    function test_Vault_CannotReduceLockupByStakingWithShorterPeriod() public {
        // Replicate the exact exploit scenario from the vulnerability report:
        // 1. User initially stakes 1,000 tokens with a 365-day lockup period
        // 2. Later, user stakes 10,000 tokens with a 30-day lockup period
        // 3. Verify that the effective lockup period cannot be reduced below the original commitment

        uint256 initialStake = 1_000 * 1e18; // 1,000 tokens
        uint256 largerStake = 10_000 * 1e18; // 10,000 tokens (10x larger)

        // Mint tokens for the test
        sapienToken.mint(user1, initialStake + largerStake);

        // Step 1: User initially stakes 1,000 tokens with 365-day lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), initialStake);
        sapienVault.stake(initialStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Verify initial stake
        (uint256 totalStaked1,,,,,, uint256 effectiveLockUpPeriod1,) = sapienVault.getUserStakingSummary(user1);
        assertEq(totalStaked1, initialStake, "Initial stake should be 1,000 tokens");
        assertEq(effectiveLockUpPeriod1, LOCK_365_DAYS, "Initial lockup should be 365 days");

        // Step 2: Later, user stakes additional 10,000 tokens with 30-day lockup
        // This should NOT reduce the effective lockup period due to the security fix
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largerStake);
        sapienVault.stake(largerStake, LOCK_30_DAYS);
        vm.stopPrank();

        // Step 3: Verify that lockup period was NOT reduced
        (uint256 totalStaked2,,,,,, uint256 effectiveLockUpPeriod2,) = sapienVault.getUserStakingSummary(user1);

        assertEq(totalStaked2, initialStake + largerStake, "Total stake should be 11,000 tokens");

        // CRITICAL ASSERTION: The effective lockup period should NOT be reduced
        // Without the fix, this would have been reduced to a much shorter period
        // With the fix, it should remain at 365 days (the longer commitment)
        assertEq(
            effectiveLockUpPeriod2,
            LOCK_365_DAYS,
            "SECURITY FIX: Effective lockup must not be reduced below original commitment"
        );

        // Additional verification: The lockup should be at least as long as the original
        assertGe(
            effectiveLockUpPeriod2,
            LOCK_365_DAYS,
            "SECURITY FIX: Cannot reduce lockup below original 365-day commitment"
        );
    }

    /**
     * @notice Test multiple attempts to reduce lockup period
     * @dev Verifies that repeated staking with shorter periods cannot gradually reduce the lockup
     */
    function test_Vault_MultipleAttemptsToReduceLockupFail() public {
        uint256 baseStake = 1_000 * 1e18;

        // Mint plenty of tokens
        sapienToken.mint(user1, baseStake * 20);

        // Start with maximum lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), baseStake);
        sapienVault.stake(baseStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Attempt multiple times to reduce lockup with larger stakes and shorter periods
        for (uint256 i = 1; i <= 5; i++) {
            vm.startPrank(user1);
            sapienToken.approve(address(sapienVault), baseStake * i);
            sapienVault.stake(baseStake * i, LOCK_30_DAYS);
            vm.stopPrank();

            // Verify lockup period was not reduced
            (,,,,,, uint256 effectiveLockUpPeriod,) = sapienVault.getUserStakingSummary(user1);
            assertEq(
                effectiveLockUpPeriod,
                LOCK_365_DAYS,
                string(abi.encodePacked("Attempt ", vm.toString(i), ": Cannot reduce lockup period"))
            );
        }

        // Final verification
        (uint256 totalStaked,,,,,, uint256 finalLockup,) = sapienVault.getUserStakingSummary(user1);
        assertEq(totalStaked, baseStake * 16, "Should have accumulated all stakes: 1+1+2+3+4+5 = 16");
        assertEq(finalLockup, LOCK_365_DAYS, "Final lockup must remain at 365 days");
    }

    /**
     * @notice Test that legitimate lockup extensions still work correctly
     * @dev Ensures the fix doesn't break legitimate functionality
     */
    function test_Vault_LegitimateExtensionsStillWork() public {
        uint256 stake1 = 1_000 * 1e18;
        uint256 stake2 = 2_000 * 1e18;

        sapienToken.mint(user1, stake1 + stake2);

        // Start with short-term stake
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), stake1);
        sapienVault.stake(stake1, LOCK_30_DAYS);
        vm.stopPrank();

        // Add stake with longer period (legitimate extension)
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), stake2);
        sapienVault.stake(stake2, LOCK_365_DAYS);
        vm.stopPrank();

        // Should use the longer period
        (uint256 totalStaked,,,,,, uint256 effectiveLockUpPeriod,) = sapienVault.getUserStakingSummary(user1);
        assertEq(totalStaked, stake1 + stake2, "Should have combined stakes");
        assertEq(effectiveLockUpPeriod, LOCK_365_DAYS, "Should use longer lockup period");
    }

    /**
     * @notice Test edge case with time elapsed
     * @dev Verifies protection works even when some time has passed on the original stake
     */
    function test_Vault_ProtectionWorksWithTimeElapsed() public {
        uint256 smallStake = 1_000 * 1e18;
        uint256 largeStake = 50_000 * 1e18;

        sapienToken.mint(user1, smallStake + largeStake);

        // Initial stake with long lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), smallStake);
        sapienVault.stake(smallStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Fast forward significantly (but not completely)
        vm.warp(block.timestamp + 300 days); // 300 out of 365 days passed

        // Check remaining time
        (,,,,,, uint256 lockupBefore, uint256 timeRemainingBefore) = sapienVault.getUserStakingSummary(user1);
        assertEq(lockupBefore, LOCK_365_DAYS, "Original lockup period should be 365 days");
        assertApproxEqAbs(timeRemainingBefore, 65 days, 1, "Should have ~65 days remaining");

        // Try to exploit with much larger stake and short period
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largeStake);
        sapienVault.stake(largeStake, LOCK_30_DAYS);
        vm.stopPrank();

        // Verify the remaining commitment is still respected
        (uint256 totalStaked,,,,,, uint256 effectiveLockUpAfter,) = sapienVault.getUserStakingSummary(user1);

        assertEq(totalStaked, smallStake + largeStake, "Should have combined stakes");

        // The effective lockup should be at least the remaining commitment time
        // In the fixed implementation, the weighted start time gets reset, so we need to check
        // that the effective lockup period protects against reducing the original commitment
        assertGe(
            effectiveLockUpAfter,
            timeRemainingBefore,
            "SECURITY FIX: Effective lockup must protect remaining commitment time"
        );

        // Also verify it's at least as long as the new stake's lockup period
        assertGe(effectiveLockUpAfter, LOCK_30_DAYS, "Effective lockup must be at least as long as new stake period");
    }
}
