// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.8.30;

import {Test} from "lib/forge-std/src/Test.sol";
import {SapienVault, ISapienVault} from "src/SapienVault.sol";
import {ERC1967Proxy} from "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {MockERC20} from "test/mocks/MockERC20.sol";
import {Constants as Const} from "src/utils/Constants.sol";

/**
 * @title SapienVault Lockup Vulnerability Test
 * @notice Tests to verify that the lockup period reduction vulnerability has been properly addressed
 * @dev This test file specifically addresses the vulnerability report:
 *      "Lockup Period for Unstaking Can Be Decreased by Staking Again with Shorter Lockup Period"
 *
 *      NOTE: The security fix now requires users with existing stakes to use increaseAmount()
 *      instead of stake() for subsequent stakes. This prevents lockup period manipulation.
 */
contract SapienVaultLockupVulnerabilityTest is Test {
    SapienVault public sapienVault;
    MockERC20 public sapienToken;

    address public admin = makeAddr("admin");
    address public treasury = makeAddr("treasury");
    address public user1 = makeAddr("user1");

    uint256 public constant MINIMUM_STAKE = 1000e18; // 1,000 SAPIEN
    uint256 public constant LOCK_30_DAYS = 30 days;
    uint256 public constant LOCK_90_DAYS = 90 days;
    uint256 public constant LOCK_180_DAYS = 180 days;
    uint256 public constant LOCK_365_DAYS = 365 days;

    function setUp() public {
        // Deploy mock SAPIEN token
        sapienToken = new MockERC20("Sapien", "SAPIEN", 18);

        // Deploy SapienVault
        SapienVault sapienVaultImpl = new SapienVault();
        address dummySapienQA = makeAddr("dummySapienQA");
        bytes memory initData = abi.encodeWithSelector(
            SapienVault.initialize.selector,
            address(sapienToken),
            admin,
            makeAddr("pauseManager"),
            treasury,
            dummySapienQA
        );
        ERC1967Proxy sapienVaultProxy = new ERC1967Proxy(address(sapienVaultImpl), initData);
        sapienVault = SapienVault(address(sapienVaultProxy));

        // Mint tokens to user
        sapienToken.mint(user1, 100_000_000 * 1e18); // 100M tokens for testing
    }

    /**
     * @notice Test the exact exploit scenario described in the vulnerability report
     * @dev This test demonstrates that the vulnerability has been fixed
     */
    function test_Vault_CannotReduceLockupByStakingWithShorterPeriod() public {
        // The original exploit scenario is no longer possible due to the security fix:
        // Users with existing stakes must use increaseAmount() instead of stake()
        // This test verifies that the exploit path is blocked

        uint256 initialStake = 1_000 * 1e18; // 1,000 tokens
        uint256 largerStake = 2_000 * 1e18; // 2,000 tokens (within 2.5K limit)

        // Mint tokens for the test
        sapienToken.mint(user1, initialStake + largerStake);

        // Step 1: User initially stakes 1,000 tokens with 365-day lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), initialStake);
        sapienVault.stake(initialStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Verify initial stake
        ISapienVault.UserStakingSummary memory initialUserStake = sapienVault.getUserStakingSummary(user1);
        assertEq(initialUserStake.userTotalStaked, initialStake, "Initial stake should be 1,000 tokens");
        assertEq(initialUserStake.effectiveLockUpPeriod, LOCK_365_DAYS, "Initial lockup should be 365 days");

        // Step 2: Attempt to stake additional tokens to exploit lockup reduction
        // This should FAIL due to the security fix - must use increaseAmount() instead
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largerStake);

        // This should revert with ExistingStakeFound error
        vm.expectRevert(ISapienVault.ExistingStakeFound.selector);
        sapienVault.stake(largerStake, LOCK_30_DAYS);
        vm.stopPrank();

        // Step 3: Verify that using increaseAmount() preserves the original lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largerStake);
        sapienVault.increaseAmount(largerStake);
        vm.stopPrank();

        // Verify the security fix works
        ISapienVault.UserStakingSummary memory userStake2 = sapienVault.getUserStakingSummary(user1);
        assertEq(userStake2.userTotalStaked, initialStake + largerStake, "Total stake should be 11,000 tokens");

        // CRITICAL ASSERTION: The effective lockup period should remain unchanged
        assertEq(
            userStake2.effectiveLockUpPeriod,
            LOCK_365_DAYS,
            "SECURITY FIX: Effective lockup must not be reduced - increaseAmount() preserves original lockup"
        );
    }

    /**
     * @notice Test multiple attempts to reduce lockup period
     * @dev Verifies that repeated staking attempts are blocked by the security fix
     */
    function test_Vault_MultipleAttemptsToReduceLockupFail() public {
        uint256 baseStake = 1_000 * 1e18;

        // Mint plenty of tokens
        sapienToken.mint(user1, baseStake * 20);

        // Start with maximum lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), baseStake);
        sapienVault.stake(baseStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Attempt multiple times to reduce lockup - should all fail
        // Note: Keep amounts within 2.5K limit to ensure we test ExistingStakeFound, not StakeAmountTooLarge
        uint256[] memory stakeAmounts = new uint256[](3);
        stakeAmounts[0] = 500 * 1e18; // 500 tokens
        stakeAmounts[1] = 800 * 1e18; // 800 tokens
        stakeAmounts[2] = 1_000 * 1e18; // 1,000 tokens

        for (uint256 i = 0; i < stakeAmounts.length; i++) {
            vm.startPrank(user1);
            sapienToken.approve(address(sapienVault), stakeAmounts[i]);

            // Each attempt should revert with ExistingStakeFound
            vm.expectRevert(ISapienVault.ExistingStakeFound.selector);
            sapienVault.stake(stakeAmounts[i], LOCK_30_DAYS);
            vm.stopPrank();
        }

        // Verify original stake remains unchanged
        ISapienVault.UserStakingSummary memory finalUserStake = sapienVault.getUserStakingSummary(user1);
        assertEq(finalUserStake.userTotalStaked, baseStake, "Should only have original stake");
        assertEq(finalUserStake.effectiveLockUpPeriod, LOCK_365_DAYS, "Lockup must remain at 365 days");

        // Now test that using increaseAmount() works correctly (preserves lockup)
        // Use 1,400 tokens to stay within 2.5K limit (1,000 + 1,400 = 2,400)
        uint256 increaseAmount = 1_400 * 1e18;
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), increaseAmount);
        sapienVault.increaseAmount(increaseAmount);
        vm.stopPrank();

        ISapienVault.UserStakingSummary memory afterIncrease = sapienVault.getUserStakingSummary(user1);
        assertEq(afterIncrease.userTotalStaked, baseStake + increaseAmount, "Should have increased stake amount");
        assertEq(afterIncrease.effectiveLockUpPeriod, LOCK_365_DAYS, "Lockup must remain at 365 days");
    }

    /**
     * @notice Test that legitimate lockup extensions still work correctly
     * @dev Ensures the fix doesn't break legitimate functionality
     */
    function test_Vault_LegitimateExtensionsStillWork() public {
        uint256 stake1 = 1_000 * 1e18;
        uint256 stake2 = 2_000 * 1e18;

        sapienToken.mint(user1, stake1 + stake2);

        // Start with short-term stake
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), stake1);
        sapienVault.stake(stake1, LOCK_30_DAYS);
        vm.stopPrank();

        // Cannot use stake() for additional tokens - must use increaseAmount() or increaseLockup()
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), stake2);

        // This should fail with ExistingStakeFound
        vm.expectRevert(ISapienVault.ExistingStakeFound.selector);
        sapienVault.stake(stake2, LOCK_365_DAYS);
        vm.stopPrank();

        // Instead, use increaseLockup() to extend the lockup period
        vm.startPrank(user1);
        sapienVault.increaseLockup(LOCK_365_DAYS - LOCK_30_DAYS); // Extend to 365 days total
        vm.stopPrank();

        // Then increase the amount
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), stake2);
        sapienVault.increaseAmount(stake2);
        vm.stopPrank();

        // Should have combined stakes with longer period
        ISapienVault.UserStakingSummary memory userStakeAfter = sapienVault.getUserStakingSummary(user1);
        assertEq(userStakeAfter.userTotalStaked, stake1 + stake2, "Should have combined stakes");
        assertEq(userStakeAfter.effectiveLockUpPeriod, LOCK_365_DAYS, "Should use longer lockup period");
    }

    /**
     * @notice Test edge case with time elapsed
     * @dev Verifies protection works even when some time has passed on the original stake
     */
    function test_Vault_ProtectionWorksWithTimeElapsed() public {
        uint256 smallStake = 1_000 * 1e18;
        uint256 largeStake = 1_400 * 1e18; // Within 2.5K limit (1000 + 1400 = 2400)

        sapienToken.mint(user1, smallStake + largeStake);

        // Initial stake with long lockup
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), smallStake);
        sapienVault.stake(smallStake, LOCK_365_DAYS);
        vm.stopPrank();

        // Fast forward significantly (but not completely)
        vm.warp(block.timestamp + 300 days); // 300 out of 365 days passed

        // Check remaining time
        ISapienVault.UserStakingSummary memory userStakeBefore = sapienVault.getUserStakingSummary(user1);
        assertEq(userStakeBefore.effectiveLockUpPeriod, LOCK_365_DAYS, "Original lockup period should be 365 days");

        // Calculate time remaining (this is a simplified calculation for the test)
        uint256 timeRemainingBefore = sapienVault.getTimeUntilUnlock(user1);
        assertApproxEqAbs(timeRemainingBefore, 65 days, 1 days, "Should have ~65 days remaining");

        // Try to exploit with much larger stake and short period - should fail
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largeStake);
        vm.expectRevert(ISapienVault.ExistingStakeFound.selector);
        sapienVault.stake(largeStake, LOCK_30_DAYS);
        vm.stopPrank();

        // Use increaseAmount() instead
        vm.startPrank(user1);
        sapienToken.approve(address(sapienVault), largeStake);
        sapienVault.increaseAmount(largeStake);
        vm.stopPrank();

        // Verify the remaining commitment is still respected
        ISapienVault.UserStakingSummary memory userStakeAfterIncrease = sapienVault.getUserStakingSummary(user1);

        assertEq(userStakeAfterIncrease.userTotalStaked, smallStake + largeStake, "Should have combined stakes");

        // The effective lockup should maintain the original commitment
        assertEq(
            userStakeAfterIncrease.effectiveLockUpPeriod,
            LOCK_365_DAYS,
            "SECURITY FIX: Effective lockup must preserve original commitment"
        );
    }
}
